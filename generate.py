import sys
import xml.etree.cElementTree as ET

class Extension:
	def __init__(self, condition, commands):
		self.condition = condition
		self.commands = commands

vkFile = sys.argv[1]
vkTree = ET.ElementTree(file=vkFile)

# Get extensions 
extensions = []
for extension in vkTree.iterfind('extensions/extension'):
	commands = []
	for command in extension.iterfind('require/command'):
		commands.append(command.attrib['name'])
	extensions.append(Extension(extension.attrib['name'], commands))

# Gather all extension commands
extension_commands = []
for extension in extensions:
	if extension.commands:
		for command in extension.commands:
			extension_commands.append(command)

# Get commands
commands = []
for command in vkTree.iterfind('commands/command'):
	command = command.findtext('proto/name')
	if command not in extension_commands:
		commands.append(command)

def genCmd(f, gen):
	for command in commands:
		gen(f, command)
	
	for extension in extensions:
		if extension.commands:
			f.write('#ifdef '  + extension.condition + '\n')
			for command in extension.commands:
				gen(f, command)
			f.write('#endif\n')

def genDeclaration(f, command):
		f.write('extern PFN_' + command + ' vkLoader_' + command + ';\n')
		f.write('#define ' + command + ' vkLoader_' + command + '\n')

def genDefinition(f, command):
	f.write('PFN_' + command + ' vkLoader_' + command + ';\n')	

def genInstanceAddr(f, command):
	f.write('    vkLoader_' + command + ' = (PFN_' + command + ') vkGetInstanceProcAddr(instance, "' + command + '");\n')
	
def genDeviceAddr(f, command):
	f.write('    vkLoader_' + command + ' = (PFN_' + command + ') vkGetDeviceProcAddr(device, "' + command + '");\n')
	
# Write header file
with open('vk_loader/vk_loader.h', 'w') as f:
	f.write('''/* This header is autogenerated */

#ifndef VK_LOADER_H
#define VK_LOADER_H

#define VK_NO_PROTOTYPES
#include <vulkan/vulkan.h>

#ifdef __cplusplus
extern "C" {
#endif

''')

	genCmd(f, genDeclaration)
		
	f.write('''
	
extern VkBool32 vkLoaderInit();
extern VkBool32 vkLoaderInstanceInit(VkInstance instance);
extern VkBool32 vkLoaderDeviceInit(VkDevice device);

#ifdef __cplusplus
}
#endif
#endif
''')

# Write implementation file
with open('vk_loader/vk_loader.cpp', 'w') as f:
	f.write('''/* This header is autogenerated */
	
#include "vk_loader.h"

#ifndef _WIN32
#include <dlfcn.h>
#else
#include <Windows.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

''')
	genCmd(f, genDefinition)
	f.write('''
	
static void* vkLoaderHandle = NULL;


#ifndef _WIN32
#define vkLoaderPlatformOpenLibrary(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL)
#define vkLoaderPlatformGetProcAddr(handle, name) dlsym(handle, name)
#else
#define vkLoaderPlatformOpenLibrary(name) LoadLibraryA(name)
#define vkLoaderPlatformGetProcAddr(handle, name) GetProcAddress((HMODULE) handle, name)
#endif

VkBool32 vkLoaderInit()
{

#ifndef _WIN32
    const char* libName = "libvulkan.so.1";
#else
	const char* libName = "vulkan-1.dll";
#endif

    if (!vkLoaderHandle)
    {
        vkLoaderHandle = vkLoaderPlatformOpenLibrary(libName);
    }

    if (vkLoaderHandle)
    {
        vkLoader_vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)(vkLoaderPlatformGetProcAddr(vkLoaderHandle, "vkGetInstanceProcAddr"));
        if (!vkLoader_vkGetInstanceProcAddr)
		{
            return VK_FALSE;
		}
    }
	else
	{
		return VK_FALSE;
	}

	vkLoader_vkEnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties) vkGetInstanceProcAddr(nullptr, "vkEnumerateInstanceExtensionProperties");
	vkLoader_vkEnumerateInstanceLayerProperties = (PFN_vkEnumerateInstanceLayerProperties) vkGetInstanceProcAddr(nullptr, "vkEnumerateInstanceLayerProperties");
	vkLoader_vkCreateInstance = (PFN_vkCreateInstance) vkGetInstanceProcAddr(nullptr, "vkCreateInstance");
	
	return VK_TRUE;
}

VkBool32 vkLoaderInstanceInit(VkInstance instance)
{
	if (!vkLoaderHandle) return VK_FALSE;

''')
	genCmd(f, genInstanceAddr)
	f.write('''
	
	return VK_TRUE;
}

VkBool32 vkLoaderDeviceInit(VkDevice device)
{
	if (!vkLoaderHandle) return VK_FALSE;

''')
	genCmd(f, genDeviceAddr)
	f.write('''
	
	return VK_TRUE;
}

#ifdef __cplusplus
}
#endif

''')