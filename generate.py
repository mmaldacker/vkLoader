import sys
import xml.etree.cElementTree as ET
from collections import defaultdict

def itertext(self):
  tag = self.tag
  if not isinstance(tag, str) and tag is not None:
    return
  if self.text:
    yield self.text
  for e in self:
    for s in e.itertext():
      yield s
    if e.tail:
      yield e.tail

vkFile = sys.argv[1]
vkTree = ET.ElementTree(file=vkFile)

# Get proto
def getProtoStub(command):
  returnType = command.findtext('proto/type')
  proto = 'VKAPI_ATTR ' + returnType + ' VKAPI_CALL ' + command.findtext('proto/name') + '_stub'
  params = []
  for param in command.iterfind('param'):
    params.append(' '.join(param.itertext()))
  proto += '(' + ','.join(params) + ')'
  if returnType == 'VkResult':
	proto += '\n{\n    return VK_ERROR_EXTENSION_NOT_PRESENT;\n}\n'
  elif returnType == 'PFN_vkVoidFunction':
	proto += '\n{\n    return NULL;\n}\n'
  else:
    proto += '{}\n'
  return proto
  
def getProtoForward(command):
  returnType = command.findtext('proto/type')
  proto = 'VKAPI_ATTR ' + returnType + ' VKAPI_CALL ' + command.findtext('proto/name')
  params = []
  for param in command.iterfind('param'):
    params.append(' '.join(param.itertext()))
  proto += '(' + ','.join(params) + ')\n{\n'
  if returnType != 'void':
	  proto += '    return '
  else:
    proto += '    '
  args = [arg.text for arg in command.iterfind('param/name')]
  proto += 'vkLoader_' + command.findtext('proto/name') + '(' + ','.join(args) + ');\n}\n'
  return proto  

class FunctionDef:
  def __init__(self, forward, stub):
    self.forward = forward
    self.stub = stub

# Get commands
commands = {}
for command in vkTree.iterfind('commands/command'):
		commands[command.findtext('proto/name')] = FunctionDef(getProtoForward(command), getProtoStub(command))

# Get extensions
extensions = defaultdict(list)
for extension in vkTree.iterfind('extensions/extension'):
  for command in extension.iterfind('require/command'):
    extensions[extension.attrib['name']].append(command.attrib['name'])

def genCmd(f, gen):
  for command, proto in commands.iteritems():
    if not any(command in val for val in extensions.values()):
      gen(f, command)

def genExtensionCmd(f, gen):
	for extension, commands in extensions.iteritems():
		if commands:
			f.write('#ifdef '  + extension + '\n')
			for command in commands:
				gen(f, command)
			f.write('#endif\n')

def genDeclaration(f, command):
  f.write('extern PFN_' + command + ' vkLoader_' + command + ';\n')

def genProtoStub(f, command):
  f.write('PFN_' + command + ' vkLoader_' + command + ';\n')
  f.write(commands[command].stub)
  f.write(commands[command].forward)

def genProtoForward(f, command):
  f.write('PFN_' + command + ' vkLoader_' + command + ';\n')
  f.write(commands[command].forward)

def genInstanceAddr(f, command):
	f.write('    vkLoader_' + command + ' = (PFN_' + command + ') vkGetInstanceProcAddr(instance, "' + command + '");\n')
	
def genDeviceAddr(f, command):
	f.write('    vkLoader_' + command + ' = (PFN_' + command + ') vkGetDeviceProcAddr(device, "' + command + '");\n')

def genInstanceStub(f, command):
  f.write('    vkLoader_' + command + ' = (PFN_' + command + ') ' + command + '_stub;\n')

# Write header file
with open('vk_loader/vk_loader.h', 'w') as f:
	f.write('''/* This header is autogenerated */

#ifndef VK_LOADER_H
#define VK_LOADER_H

#include <vulkan/vulkan.h>

#ifdef __cplusplus
extern "C" {
#endif

''')
	genCmd(f, genDeclaration)
	genExtensionCmd(f, genDeclaration)
	f.write('''

extern VkBool32 vkLoaderInit();
extern VkBool32 vkLoaderInstanceInit(VkInstance instance);
extern VkBool32 vkLoaderInstanceExtensionInit(VkInstance instance, const char* extension);
extern VkBool32 vkLoaderDeviceExtensionInit(VkDevice device, const char* extension);

#ifdef __cplusplus
}
#endif
#endif
''')

# Write implementation file
with open('vk_loader/vk_loader.cpp', 'w') as f:
  f.write('''/* This header is autogenerated */
	
#include "vk_loader.h"
#include <string.h>

#ifndef _WIN32
#include <dlfcn.h>
#else
#include <Windows.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

''')
  genCmd(f, genProtoForward)
  genExtensionCmd(f, genProtoStub)
  f.write('''
	
static void* vkLoaderHandle = NULL;


#ifndef _WIN32
#define vkLoaderPlatformOpenLibrary(name) dlopen(name, RTLD_LAZY | RTLD_LOCAL | RTLD_DEEPBIND)
#define vkLoaderPlatformGetProcAddr(handle, name) dlsym(handle, name)
#else
#define vkLoaderPlatformOpenLibrary(name) LoadLibraryA(name)
#define vkLoaderPlatformGetProcAddr(handle, name) GetProcAddress((HMODULE) handle, name)
#endif

VkBool32 vkLoaderInit()
{

#ifndef _WIN32
    const char* libName = "libvulkan.so.1";
#else
    const char* libName = "vulkan-1.dll";
#endif

    if (!vkLoaderHandle)
    {
        vkLoaderHandle = vkLoaderPlatformOpenLibrary(libName);
    }

    if (vkLoaderHandle)
    {
        vkLoader_vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)(vkLoaderPlatformGetProcAddr(vkLoaderHandle, "vkGetInstanceProcAddr"));
        if (!vkLoader_vkGetInstanceProcAddr)
		    {
            return VK_FALSE;
		    }
    }
    else
    {
        return VK_FALSE;
    }

    vkLoader_vkEnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties) vkGetInstanceProcAddr(nullptr, "vkEnumerateInstanceExtensionProperties");
    vkLoader_vkEnumerateInstanceLayerProperties = (PFN_vkEnumerateInstanceLayerProperties) vkGetInstanceProcAddr(nullptr, "vkEnumerateInstanceLayerProperties");
    vkLoader_vkCreateInstance = (PFN_vkCreateInstance) vkGetInstanceProcAddr(nullptr, "vkCreateInstance");
	
    return VK_TRUE;
}

VkBool32 vkLoaderInstanceInit(VkInstance instance)
{
    if (!vkLoaderHandle) return VK_FALSE;

''')
  genCmd(f, genInstanceAddr)
  genExtensionCmd(f, genInstanceStub)
  f.write('''
	
    return VK_TRUE;
}

VkBool32 vkLoaderInstanceExtensionInit(VkInstance instance, const char* extension)
{
    if (!vkLoaderHandle) return VK_FALSE;

''')
  for extension, commands in extensions.iteritems():
    if commands:
      f.write('#ifdef '  + extension + '\n')
      f.write('    if (strcmp("' + extension + '", extension) == 0)\n    {\n')
      for command in commands:
        genInstanceAddr(f, command)
      f.write('    return VK_TRUE;\n    }\n')
      f.write('#endif\n')
  f.write('''
  
    return VK_FALSE;
}

extern VkBool32 vkLoaderDeviceExtensionInit(VkDevice device, const char* extension)
{
    if (!vkLoaderHandle) return VK_FALSE;

''')
  for extension, commands in extensions.iteritems():
    if commands:
      f.write('#ifdef '  + extension + '\n')
      f.write('    if (strcmp("' + extension + '", extension) == 0)\n    {\n')
      for command in commands:
        genDeviceAddr(f, command)
      f.write('    return VK_TRUE;\n    }\n')
      f.write('#endif\n')
  f.write('''
  
    return VK_FALSE;
}

#ifdef __cplusplus
}
#endif

''')
